{"ast":null,"code":"import { appKey } from 'configs';\nimport RequestStore from './requestStore';\n\nconst getToken = () => {\n  const data = localStorage.getItem(\"\".concat(appKey, \"-token\"));\n  return JSON.parse(data);\n};\n\nconst makeUnique = (url, method) => \"\".concat(url, \"-\").concat(method); // TODO:: can method allow all types?\n\n\nclass Fetch {\n  static async get(url, signal) {\n    return Fetch.request(url, 'GET', null, signal);\n  }\n\n  static async post(url, data, signal) {\n    return Fetch.request(url, 'POST', data, signal);\n  }\n\n  static async put(url, data, signal) {\n    return Fetch.request(url, 'PUT', data, signal);\n  }\n\n  static async request(url, method, data, signal) {\n    const headers = {\n      'Content-Type': 'application/json',\n      'Authentication': getToken()\n    };\n    const body = method === 'POST' || method === 'PUT' ? JSON.stringify(data) : null;\n    const response = await Fetch.cachableRequest(url, method, headers, body, signal);\n    return await response.clone().json();\n  }\n\n  static async cachableRequest(url, method, headers, body, signal) {\n    // hashing endpoint uniquely\n    const hash = makeUnique(url, method);\n    /** Existence in \"RequestStore\" will mean that same request is already has \"pending\" status,\n     * so no need to request it twice.\n     * Store request for further exploitation.\n     */\n\n    const request = RequestStore.has(hash) ? RequestStore.get(hash) : fetch(url, {\n      method,\n      headers,\n      body,\n      signal\n    });\n    RequestStore.set(hash, request);\n    const response = await request;\n    RequestStore.drop(hash);\n    return response;\n  }\n\n}\n\nexport default Fetch;","map":{"version":3,"sources":["/Users/levonazizyan/Desktop/LevelUP/Course Levelup/src/utils/fetch/base.js"],"names":["appKey","RequestStore","getToken","data","localStorage","getItem","JSON","parse","makeUnique","url","method","Fetch","get","signal","request","post","put","headers","body","stringify","response","cachableRequest","clone","json","hash","has","fetch","set","drop"],"mappings":"AAAA,SAASA,MAAT,QAAuB,SAAvB;AACA,OAAOC,YAAP,MAAyB,gBAAzB;;AAEA,MAAMC,QAAQ,GAAG,MAAM;AACrB,QAAMC,IAAI,GAAGC,YAAY,CAACC,OAAb,WAAwBL,MAAxB,YAAb;AACA,SAAOM,IAAI,CAACC,KAAL,CAAWJ,IAAX,CAAP;AACD,CAHD;;AAKA,MAAMK,UAAU,GAAG,CAACC,GAAD,EAAMC,MAAN,eAAoBD,GAApB,cAA2BC,MAA3B,CAAnB,C,CAAwD;;;AAExD,MAAMC,KAAN,CAAY;AAEV,eAAaC,GAAb,CAAiBH,GAAjB,EAAsBI,MAAtB,EAA8B;AAC5B,WAAOF,KAAK,CAACG,OAAN,CAAcL,GAAd,EAAmB,KAAnB,EAA0B,IAA1B,EAAgCI,MAAhC,CAAP;AACD;;AAED,eAAaE,IAAb,CAAkBN,GAAlB,EAAuBN,IAAvB,EAA6BU,MAA7B,EAAqC;AACnC,WAAOF,KAAK,CAACG,OAAN,CAAcL,GAAd,EAAmB,MAAnB,EAA2BN,IAA3B,EAAiCU,MAAjC,CAAP;AACD;;AAED,eAAaG,GAAb,CAAiBP,GAAjB,EAAsBN,IAAtB,EAA4BU,MAA5B,EAAoC;AAClC,WAAOF,KAAK,CAACG,OAAN,CAAcL,GAAd,EAAmB,KAAnB,EAA0BN,IAA1B,EAAgCU,MAAhC,CAAP;AACD;;AAED,eAAaC,OAAb,CAAqBL,GAArB,EAA0BC,MAA1B,EAAkCP,IAAlC,EAAwCU,MAAxC,EAAgD;AAE9C,UAAMI,OAAO,GAAG;AACd,sBAAgB,kBADF;AAEd,wBAAkBf,QAAQ;AAFZ,KAAhB;AAKA,UAAMgB,IAAI,GAAIR,MAAM,KAAK,MAAX,IAAqBA,MAAM,KAAK,KAAjC,GAA0CJ,IAAI,CAACa,SAAL,CAAehB,IAAf,CAA1C,GAAiE,IAA9E;AAEA,UAAMiB,QAAQ,GAAG,MAAMT,KAAK,CAACU,eAAN,CAAsBZ,GAAtB,EAA2BC,MAA3B,EAAmCO,OAAnC,EAA4CC,IAA5C,EAAkDL,MAAlD,CAAvB;AACA,WAAO,MAAMO,QAAQ,CAACE,KAAT,GAAiBC,IAAjB,EAAb;AACD;;AAED,eAAaF,eAAb,CAA6BZ,GAA7B,EAAkCC,MAAlC,EAA0CO,OAA1C,EAAmDC,IAAnD,EAAyDL,MAAzD,EAAiE;AAC/D;AACA,UAAMW,IAAI,GAAGhB,UAAU,CAACC,GAAD,EAAMC,MAAN,CAAvB;AAEA;;;;;AAIA,UAAMI,OAAO,GAAGb,YAAY,CAACwB,GAAb,CAAiBD,IAAjB,IACZvB,YAAY,CAACW,GAAb,CAAiBY,IAAjB,CADY,GAEZE,KAAK,CAACjB,GAAD,EAAM;AAAEC,MAAAA,MAAF;AAAUO,MAAAA,OAAV;AAAmBC,MAAAA,IAAnB;AAAyBL,MAAAA;AAAzB,KAAN,CAFT;AAIAZ,IAAAA,YAAY,CAAC0B,GAAb,CAAiBH,IAAjB,EAAuBV,OAAvB;AAEA,UAAMM,QAAQ,GAAG,MAAMN,OAAvB;AAEAb,IAAAA,YAAY,CAAC2B,IAAb,CAAkBJ,IAAlB;AAEA,WAAOJ,QAAP;AACD;;AA9CS;;AAiDZ,eAAeT,KAAf","sourcesContent":["import { appKey } from 'configs';\nimport RequestStore from './requestStore';\n\nconst getToken = () => {\n  const data = localStorage.getItem(`${appKey}-token`);\n  return JSON.parse(data);\n}\n\nconst makeUnique = (url, method) => `${url}-${method}`; // TODO:: can method allow all types?\n\nclass Fetch {\n\n  static async get(url, signal) {\n    return Fetch.request(url, 'GET', null, signal);\n  }\n\n  static async post(url, data, signal) {\n    return Fetch.request(url, 'POST', data, signal);\n  }\n\n  static async put(url, data, signal) {\n    return Fetch.request(url, 'PUT', data, signal);\n  }\n\n  static async request(url, method, data, signal) {\n\n    const headers = {\n      'Content-Type': 'application/json',\n      'Authentication': getToken(),\n    };\n\n    const body = (method === 'POST' || method === 'PUT') ? JSON.stringify(data) : null;\n\n    const response = await Fetch.cachableRequest(url, method, headers, body, signal);\n    return await response.clone().json();\n  }\n\n  static async cachableRequest(url, method, headers, body, signal) {\n    // hashing endpoint uniquely\n    const hash = makeUnique(url, method);\n\n    /** Existence in \"RequestStore\" will mean that same request is already has \"pending\" status,\n     * so no need to request it twice.\n     * Store request for further exploitation.\n     */\n    const request = RequestStore.has(hash)\n      ? RequestStore.get(hash)\n      : fetch(url, { method, headers, body, signal });\n\n    RequestStore.set(hash, request);\n\n    const response = await request;\n\n    RequestStore.drop(hash);\n\n    return response;\n  }\n}\n\nexport default Fetch;\n"]},"metadata":{},"sourceType":"module"}